package net.opencraft;

import static java.lang.Math.*;
import static org.lwjgl.glfw.Callbacks.*;
import static org.lwjgl.glfw.GLFW.*;
import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.system.MemoryUtil.*;

import net.opencraft.client.renderer.Camera;
import net.opencraft.client.renderer.Monitor;
import net.opencraft.world.World;
import net.opencraft.world.terrain.TerrainGenerator;

import org.lwjgl.glfw.GLFWErrorCallback;
import org.lwjgl.opengl.GL;

import javax.swing.JOptionPane;
import java.util.Objects;

public class OpenCraft implements Runnable {

	// The window handle
	private long window;

	// Camera position
	private static float cameraX = 0.0f;
	private static float cameraY = 0.0f;
	private static float cameraZ = 0.0f;

	// Camera rotation
	private static float cameraYaw = 0.0f;
	private static float cameraPitch = 0.0f;

	public int width = 854;
	public int height = 480;

	public boolean running = false;
	public boolean canMoveCamera = true;
	public boolean escapeKeyPressed = false;

	public final World worldGenerator = new World();

	@Override
	public void run() {
		try {
			init();
		} catch (Exception ex) {
			JOptionPane.showMessageDialog(null, "Failed to init OpenCraft!", "Error on initialization!",
					JOptionPane.ERROR_MESSAGE);
			ex.printStackTrace();
			System.exit(1);
		}

		while (!glfwWindowShouldClose(window) && running) {
			// Update the game
			tick();
		}

		// Free the window callbacks and destroy the window
		glfwFreeCallbacks(window);
		glfwDestroyWindow(window);

		// Terminate GLFW and free the error callback
		glfwTerminate();

		Objects.requireNonNull(glfwSetErrorCallback(null), "Error callback return mustn't be null").free();
	}

	private void init() {
		/*
		 * Set up an error callback. The default implementation will print the error
		 * message in System.err
		 */
		GLFWErrorCallback.createPrint(System.err).set();

		// Initialize GLFW: Most GLFW functions will not work before doing this.
		if (!glfwInit())
			throw new IllegalStateException("Unable to initialize GLFW");

		// Configure GLFW
		glfwDefaultWindowHints(); // Optional, the current window hints are already the default
		glfwWindowHint(GLFW_VISIBLE, GLFW_TRUE); // The window will still be hidden after creation
		glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE); // The window will be resizable

		// Create the window
		window = glfwCreateWindow(this.width, this.height, "OpenCraft", NULL, NULL);
		if (window == NULL)
			throw new RuntimeException("Failed to create the GLFW window");

		/*
		 * If GLFW detects a change in the window size, invoke this callback that sets
		 * up a new projection for the current size.
		 */
		glfwSetFramebufferSizeCallback(window, (window, width, height) -> {
			// Fill the screen
			glViewport(0, 0, width, height);

			// Update the projection
			updateProjection(width, height);

			// Set current size
			this.width = width;
			this.height = height;
		});

		// Get primary monitor
		Monitor monitor = Monitor.getPrimaryMonitor();

		int wx, wy;
		wx = (monitor.width() - width) / 2;
		wy = (monitor.height() - height) / 2;

		// Move the window to the center
		glfwSetWindowPos(window, wx, wy);

		// Set the OpenGL context
		glfwMakeContextCurrent(window);
		glfwSwapInterval(1);
		glfwShowWindow(window);

		// Set up OpenGL context
		GL.createCapabilities();

		// Draw the sky
		glClearColor(0, 0.5f, 0.5f, 1);

		// Enable 3D
		glEnable(GL_DEPTH_TEST);

		// Initialize projection matrix
		updateProjection(width, height);

		// Create chunks
		var terrainGenerator = new TerrainGenerator(100);
		worldGenerator.generateTerrain(terrainGenerator);

		// Finally, mark the game as started
		this.running = true;
	}

	/**
	 * This method updates the projection mode of the screen. And it's automatically
	 * executed when the window's size changes.
	 * 
	 * @param width  the new window's width
	 * @param height the new window's height
	 */
	private void updateProjection(int width, int height) {
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();

		/* Constants */

		// The aspect ratio of the screen
		final float aspectRatio = (float) width / (float) height;

		// Field Of View
		final float fov = 85.0f;

		// I don't know what are these variables :'(
		final float near = 0.1f;
		final float far = 100.0f;
		final float f = (float) (1.0 / tan(toRadians(fov) / 2.0));

		// Distance between near and far
		// final float zRange = near - far;

		// Create frustum
		glFrustum(-aspectRatio * near * f, aspectRatio * near * f, -near * f, near * f, near, far);

		// Set the matrix mode
		glMatrixMode(GL_MODELVIEW);

		// Ready to draw
		glLoadIdentity();
	}

	/**
	 * This method process all the input generated by the user and answers moving
	 * the camera or ungrabs the mouse.
	 */
	private void handleInput() {
		/* Camera movement */
		{
			if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) {
				cameraX += SharedConstants.MOVE_SPEED * (float) sin(toRadians(cameraYaw));
				cameraY -= SharedConstants.MOVE_SPEED * (float) sin(toRadians(cameraPitch));
				cameraZ -= SharedConstants.MOVE_SPEED * (float) cos(toRadians(cameraYaw));
			}

			if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) {
				cameraX -= SharedConstants.MOVE_SPEED * (float) sin(toRadians(cameraYaw));
				cameraY += SharedConstants.MOVE_SPEED * (float) sin(toRadians(cameraPitch));
				cameraZ += SharedConstants.MOVE_SPEED * (float) cos(toRadians(cameraYaw));
			}

			if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) {
				cameraX += SharedConstants.MOVE_SPEED * (float) sin(toRadians(cameraYaw - 90));
				cameraZ -= SharedConstants.MOVE_SPEED * (float) cos(toRadians(cameraYaw - 90));
			}

			if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) {
				cameraX -= SharedConstants.MOVE_SPEED * (float) sin(toRadians(cameraYaw - 90));
				cameraZ += SharedConstants.MOVE_SPEED * (float) cos(toRadians(cameraYaw - 90));
			}

			// If can, rotate the camera at the mouse
			if (canMoveCamera) {
				double[] mouseX = new double[1];
				double[] mouseY = new double[1];
				glfwGetCursorPos(window, mouseX, mouseY);

				// The coordinates moved since last time
				float dx = (float) mouseX[0] - (float) (this.width / 2);
				float dy = (float) mouseY[0] - (float) (this.height / 2);

				cameraYaw += dx * SharedConstants.MOUSE_SENSITIVITY;
				cameraPitch += dy * SharedConstants.MOUSE_SENSITIVITY;

				// Clamp pitch
				if (cameraPitch > 89.0f) {
					cameraPitch = 89.0f;
				} else if (cameraPitch < -89.0f) {
					cameraPitch = -89.0f;
				}

				glfwSetCursorPos(window, (double) this.width / 2, (double) this.height / 2);
			}

		}

		if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {
			// Check if escape key was not pressed before
			if (!escapeKeyPressed) {
				// Disable camera movement
				canMoveCamera = !canMoveCamera;

				// Mark escape as pressed
				escapeKeyPressed = true;
			}
		} else {
			// Reset the variable
			escapeKeyPressed = false;
		}

	}

	private void tick() {
		/*
		 * Run the rendering loop until the user has attempted to close the window or
		 * has pressed the ESCAPE key.
		 */
		handleInput();

		// Draw all and reset
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		glLoadIdentity();

		// Apply camera rotations
		glRotatef(cameraPitch, 1.0f, 0.0f, 0.0f);
		glRotatef(cameraYaw, 0.0f, 1.0f, 0.0f);

		// Apply camera movements
		glTranslatef(-cameraX, -cameraY, -cameraZ);

		// Render chunks
		worldGenerator.render();

		// Swap the color buffers
		glfwSwapBuffers(window);

		/*
		 * Poll for window events. The key callback above will only be invoked during
		 * this call.
		 */
		glfwPollEvents();
	}

	/**
	 * @return a camera created with the actual camera data stored in the game.
	 */
	public static Camera getCamera() {
		return new Camera(cameraX, cameraY, cameraZ, cameraYaw, cameraPitch);
	}

	public static void main(String[] args) {
		// Creates a instance of the game
		OpenCraft game = new OpenCraft();

		// Creates a thread for multi-controlling
		Thread gameThread = new Thread(game);

		// Rename the thread and run the game
		gameThread.setName("gameThread");
		gameThread.start();

		// Wait until the game finishes
		try {
			gameThread.join();
		} catch (Exception ignored) {
			// If any exception occurs, ignore it and exit
			System.exit(0);
		}
	}
}
